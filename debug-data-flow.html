<!DOCTYPE html>
<html>
<head>
    <title>üîç Debug Data Flow - Progress Updates</title>
    <style>
        body { font-family: monospace; background: #000; color: #00ff41; padding: 20px; }
        .section { background: #111; padding: 20px; margin: 20px 0; border: 1px solid #00ff41; border-radius: 10px; }
        button { padding: 15px 30px; margin: 10px; background: #00ff41; color: #000; border: none; cursor: pointer; font-weight: bold; }
        button:hover { background: #00aa41; }
        .result { background: #001122; padding: 15px; margin: 10px 0; border-left: 3px solid #00ff41; }
        .error { border-left-color: #ff4444; color: #ff4444; }
        .success { border-left-color: #00ff41; color: #00ff41; }
        .warning { border-left-color: #ffaa00; color: #ffaa00; }
        pre { background: #000; padding: 10px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>üîç DEEP DIVE: Progress Update Data Flow</h1>
    
    <div class="section">
        <h2>üéØ Step 1: Test All Progress Endpoints</h2>
        <button onclick="testMainSite()">Test kryptterminal.com/api/progress</button>
        <button onclick="testAutonomous()">Test Autonomous Worker</button>
        <button onclick="compareAll()">Compare All Sources</button>
    </div>

    <div class="section">
        <h2>üîç Step 2: Trace Frontend Data Flow</h2>
        <button onclick="traceFrontendCalls()">Trace Frontend API Calls</button>
        <button onclick="testCaching()">Test Response Caching</button>
        <button onclick="simulatePolling()">Simulate 10x Polling</button>
    </div>

    <div class="section">
        <h2>‚ö° Step 3: Real-Time Monitoring</h2>
        <button onclick="startLiveMonitor()">Start Live Progress Monitor</button>
        <button onclick="stopLiveMonitor()">Stop Monitor</button>
        <button onclick="forceUpdate()">Force Progress Update</button>
    </div>

    <div id="results"></div>

    <script>
        let monitorInterval = null
        let lastProgress = null
        
        function addResult(message, type = 'success') {
            const div = document.createElement('div')
            div.className = 'result ' + type
            div.innerHTML = message
            document.getElementById('results').insertBefore(div, document.getElementById('results').firstChild)
            
            // Keep only last 20 results
            const results = document.getElementById('results')
            while (results.children.length > 20) {
                results.removeChild(results.lastChild)
            }
        }
        
        async function testMainSite() {
            addResult('üîç Testing kryptterminal.com/api/progress...', 'success')
            
            try {
                const start = Date.now()
                const response = await fetch('https://kryptterminal.com/api/progress', {
                    cache: 'no-cache',
                    headers: { 'Cache-Control': 'no-cache' }
                })
                const elapsed = Date.now() - start
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
                }
                
                const data = await response.json()
                const responseHeaders = {}
                response.headers.forEach((value, key) => {
                    responseHeaders[key] = value
                })
                
                addResult(`
                    <strong>‚úÖ Main Site Response (${elapsed}ms):</strong><br>
                    <strong>Components:</strong> ${data.componentsCompleted || 0}/${data.totalComponents || 4500}<br>
                    <strong>Percentage:</strong> ${data.percentComplete?.toFixed(2) || 0}%<br>
                    <strong>Last Updated:</strong> ${new Date(data.lastUpdated || Date.now()).toLocaleString()}<br>
                    <strong>Cache Headers:</strong> ${responseHeaders['cache-control'] || 'None'}<br>
                    <pre>${JSON.stringify(data, null, 2)}</pre>
                `, 'success')
                
            } catch (error) {
                addResult(`‚ùå Main Site Error: ${error.message}`, 'error')
            }
        }
        
        async function testAutonomous() {
            const workerUrl = prompt('Enter your autonomous worker URL:')
            if (!workerUrl) return
            
            addResult(`üîç Testing autonomous worker: ${workerUrl}...`, 'success')
            
            try {
                const start = Date.now()
                const response = await fetch(workerUrl + '/api/progress', {
                    cache: 'no-cache'
                })
                const elapsed = Date.now() - start
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
                }
                
                const data = await response.json()
                
                addResult(`
                    <strong>‚úÖ Autonomous Worker Response (${elapsed}ms):</strong><br>
                    <strong>Components:</strong> ${data.componentsCompleted || 0}/${data.totalComponents || 4500}<br>
                    <strong>Percentage:</strong> ${data.percentComplete?.toFixed(2) || 0}%<br>
                    <strong>Last Updated:</strong> ${new Date(data.lastUpdated || Date.now()).toLocaleString()}<br>
                    <pre>${JSON.stringify(data, null, 2)}</pre>
                `, 'success')
                
            } catch (error) {
                addResult(`‚ùå Autonomous Worker Error: ${error.message}`, 'error')
            }
        }
        
        async function compareAll() {
            addResult('üîç Comparing all progress sources...', 'success')
            
            const sources = [
                { name: 'Main Site', url: 'https://kryptterminal.com/api/progress' },
                { name: 'Main Site (No Cache)', url: 'https://kryptterminal.com/api/progress?nocache=' + Date.now() },
            ]
            
            const results = []
            
            for (const source of sources) {
                try {
                    const start = Date.now()
                    const response = await fetch(source.url, {
                        cache: 'no-cache',
                        headers: { 'Cache-Control': 'no-cache' }
                    })
                    const elapsed = Date.now() - start
                    const data = await response.json()
                    
                    results.push({
                        name: source.name,
                        success: true,
                        data: data,
                        elapsed: elapsed
                    })
                } catch (error) {
                    results.push({
                        name: source.name,
                        success: false,
                        error: error.message
                    })
                }
            }
            
            let comparison = '<strong>üìä Progress Comparison:</strong><br><br>'
            results.forEach(result => {
                if (result.success) {
                    comparison += `<strong>${result.name}:</strong> ${result.data.componentsCompleted || 0} components (${result.elapsed}ms)<br>`
                } else {
                    comparison += `<strong>${result.name}:</strong> ‚ùå ${result.error}<br>`
                }
            })
            
            // Check for discrepancies
            const validResults = results.filter(r => r.success)
            if (validResults.length > 1) {
                const components = validResults.map(r => r.data.componentsCompleted || 0)
                const allSame = components.every(c => c === components[0])
                
                if (!allSame) {
                    comparison += '<br><span style="color: #ff4444;"><strong>‚ö†Ô∏è DISCREPANCY DETECTED!</strong></span><br>'
                    comparison += 'Different sources showing different progress values!'
                } else {
                    comparison += '<br><span style="color: #44ff44;"><strong>‚úÖ All sources match</strong></span>'
                }
            }
            
            addResult(comparison, validResults.length > 0 ? 'success' : 'error')
        }
        
        async function traceFrontendCalls() {
            addResult('üîç Tracing frontend API calls...', 'success')
            
            // Override fetch to intercept calls
            const originalFetch = window.fetch
            let callCount = 0
            
            window.fetch = function(...args) {
                const url = args[0]
                if (typeof url === 'string' && url.includes('/api/progress')) {
                    callCount++
                    addResult(`üåê Frontend API Call #${callCount}: ${url}`, 'warning')
                }
                return originalFetch.apply(this, args)
            }
            
            // Restore after 30 seconds
            setTimeout(() => {
                window.fetch = originalFetch
                addResult(`‚úÖ Traced ${callCount} progress API calls in 30 seconds`, 'success')
            }, 30000)
            
            addResult('üì° Monitoring frontend API calls for 30 seconds...', 'success')
        }
        
        async function testCaching() {
            addResult('üîç Testing response caching behavior...', 'success')
            
            const tests = [
                { name: 'Normal Request', url: 'https://kryptterminal.com/api/progress' },
                { name: 'No-Cache Header', url: 'https://kryptterminal.com/api/progress', headers: { 'Cache-Control': 'no-cache' } },
                { name: 'Random Query', url: 'https://kryptterminal.com/api/progress?t=' + Date.now() },
                { name: 'Force Reload', url: 'https://kryptterminal.com/api/progress', cache: 'reload' }
            ]
            
            for (const test of tests) {
                try {
                    const start = Date.now()
                    const response = await fetch(test.url, {
                        cache: test.cache || 'no-cache',
                        headers: test.headers || {}
                    })
                    const elapsed = Date.now() - start
                    const data = await response.json()
                    
                    addResult(`${test.name}: ${data.componentsCompleted || 0} components (${elapsed}ms)`, 'success')
                } catch (error) {
                    addResult(`${test.name}: ‚ùå ${error.message}`, 'error')
                }
                
                // Small delay between tests
                await new Promise(r => setTimeout(r, 500))
            }
        }
        
        async function simulatePolling() {
            addResult('‚ö° Simulating rapid polling (10x for 30 seconds)...', 'success')
            
            let pollCount = 0
            let values = []
            
            const rapidPoll = setInterval(async () => {
                try {
                    const response = await fetch('https://kryptterminal.com/api/progress?poll=' + Date.now(), {
                        cache: 'no-cache'
                    })
                    const data = await response.json()
                    pollCount++
                    values.push(data.componentsCompleted || 0)
                    
                    if (pollCount % 5 === 0) {
                        const unique = [...new Set(values)]
                        addResult(`Poll #${pollCount}: ${data.componentsCompleted || 0} components (${unique.length} unique values seen)`, 'warning')
                    }
                } catch (error) {
                    addResult(`Poll #${pollCount} failed: ${error.message}`, 'error')
                }
            }, 100) // Every 100ms
            
            setTimeout(() => {
                clearInterval(rapidPoll)
                const unique = [...new Set(values)]
                addResult(`‚úÖ Rapid polling complete: ${pollCount} polls, saw ${unique.length} unique values: [${unique.slice(0, 10).join(', ')}${unique.length > 10 ? '...' : ''}]`, 'success')
            }, 30000)
        }
        
        async function startLiveMonitor() {
            if (monitorInterval) {
                addResult('‚ö†Ô∏è Monitor already running', 'warning')
                return
            }
            
            addResult('üî¥ Starting live progress monitor...', 'success')
            
            monitorInterval = setInterval(async () => {
                try {
                    const response = await fetch('https://kryptterminal.com/api/progress?live=' + Date.now(), {
                        cache: 'no-cache'
                    })
                    const data = await response.json()
                    const components = data.componentsCompleted || 0
                    
                    if (lastProgress === null) {
                        lastProgress = components
                        addResult(`üéØ Live Monitor Started - Initial: ${components} components`, 'success')
                    } else if (components !== lastProgress) {
                        const change = components - lastProgress
                        addResult(`üìà PROGRESS CHANGE DETECTED: ${lastProgress} ‚Üí ${components} (${change > 0 ? '+' : ''}${change})`, 'success')
                        lastProgress = components
                    } else {
                        // Only show every 10th "no change" to reduce spam
                        if (Math.random() < 0.1) {
                            addResult(`‚è∏Ô∏è No change: ${components} components`, 'warning')
                        }
                    }
                } catch (error) {
                    addResult(`‚ùå Monitor error: ${error.message}`, 'error')
                }
            }, 1000)
        }
        
        function stopLiveMonitor() {
            if (monitorInterval) {
                clearInterval(monitorInterval)
                monitorInterval = null
                lastProgress = null
                addResult('‚èπÔ∏è Live monitor stopped', 'success')
            } else {
                addResult('‚ö†Ô∏è No monitor running', 'warning')
            }
        }
        
        async function forceUpdate() {
            addResult('‚ö° Forcing progress update...', 'success')
            
            try {
                // Try to trigger development
                const response = await fetch('https://kryptterminal.com/api/development/force', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                })
                
                if (response.ok) {
                    const result = await response.json()
                    addResult(`‚úÖ Forced update: ${result.message || 'Success'}`, 'success')
                    
                    // Check if progress actually changed
                    setTimeout(async () => {
                        const checkResponse = await fetch('https://kryptterminal.com/api/progress?check=' + Date.now())
                        const checkData = await checkResponse.json()
                        addResult(`üìä Progress after force: ${checkData.componentsCompleted || 0} components`, 'success')
                    }, 2000)
                } else {
                    throw new Error(`HTTP ${response.status}`)
                }
            } catch (error) {
                addResult(`‚ùå Force update failed: ${error.message}`, 'error')
            }
        }
        
        // Auto-start with main site test
        window.onload = function() {
            addResult('üöÄ Debug tool loaded - starting initial tests...', 'success')
            testMainSite()
        }
    </script>
</body>
</html>